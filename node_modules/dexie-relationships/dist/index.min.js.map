{"version":3,"file":null,"sources":["../src/utils.js","../src/schema-parser.js","../src/index.js"],"sourcesContent":["\nexport function isIndexableType (value) {\n  return value != null && (// Using \"!=\" instead of \"!==\" to check for both null and undefined!\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      value instanceof Date ||\n      (Array.isArray(value) && value.every(isIndexableType))\n    )\n}\n","class SchemaParser {\n\n  /**\n   * Schema parser\n   *\n   * @param schema\n   */\n  constructor (schema) {\n    this.schema = schema\n  }\n\n  /**\n   * Extracts foreign keys from the schema\n   *\n   * @returns Object\n   */\n  getForeignKeys () {\n    let foreignKeys = {}\n\n    Object.keys(this.schema).forEach(table => {\n      let indexes = this.schema[table].split(',')\n\n      foreignKeys[table] = indexes\n        .filter(idx => idx.indexOf('->') !== -1)\n        .map(idx => {\n          // split the column and foreign table info\n          let [column, target] = idx.split('->').map(x => x.trim())\n\n          return {\n            index: column,\n            targetTable: target.split('.')[0],\n            targetIndex: target.split('.')[1]\n          }\n        })\n    })\n\n    return foreignKeys\n  }\n\n  /**\n   * Get schema without the foreign key definitions\n   *\n   * @returns Object\n   */\n  getCleanedSchema () {\n    let schema = {}\n\n    Object.keys(this.schema).forEach(table => {\n      let indexes = this.schema[table].split(',')\n\n      // Remove foreign keys syntax before calling the original method\n      schema[table] = indexes.map(idx => idx.split('->')[0].trim()).join(',')\n    })\n\n    return schema\n  }\n}\n\nexport default SchemaParser\n","import Dexie from 'dexie'\nimport SchemaParser from './schema-parser'\nimport {isIndexableType} from './utils'\n\nconst Relationships = (db) => {\n  // Use Dexie.Promise to ensure transaction safety.\n  const Promise = Dexie.Promise\n\n  /**\n   * Iterate through all items and collect related records\n   *\n   * @param relationships\n   *\n   * @returns {Dexie.Promise}\n   */\n  db.Table.prototype.with = function (relationships) {\n    return this.toCollection().with(relationships)\n  }\n\n  /**\n   * Iterate through all items and collect related records\n   *\n   * @param relationships\n   *\n   * @returns {Dexie.Promise}\n   */\n  db.Collection.prototype.with = function (relationships) {\n    const baseTable = this._ctx.table.name\n    const databaseTables = db._allTables\n\n    // this holds tables that have foreign keys pointing at the current table\n    let usableForeignTables = []\n\n    // validate target tables and add them into our usable tables object\n    Object.keys(relationships).forEach((column) => {\n      let tableOrIndex = relationships[column]\n      let matchingIndex = this._ctx.table.schema.idxByName[tableOrIndex]\n\n      if (matchingIndex && matchingIndex.hasOwnProperty('foreignKey')) {\n        let index = matchingIndex\n        usableForeignTables.push({\n          column: column,\n          index: index.foreignKey.targetIndex,\n          tableName: index.foreignKey.targetTable,\n          targetIndex: index.foreignKey.index,\n          oneToOne: true\n        })\n      } else {\n        let table = tableOrIndex\n\n        if (!databaseTables.hasOwnProperty(table)) {\n          throw new Error('Relationship table ' + table + ' doesn\\'t exist.')\n        }\n\n        if (!databaseTables[table].schema.hasOwnProperty('foreignKeys')) {\n          throw new Error('Relationship table ' + table + ' doesn\\'t have foreign keys set.')\n        }\n\n        // remove the foreign keys that don't link to the base table\n        let columns = databaseTables[table].schema.foreignKeys.filter(column => column.targetTable === baseTable)\n\n        if (columns.length > 0) {\n          usableForeignTables.push({\n            column: column,\n            index: columns[0].index,\n            tableName: table,\n            targetIndex: columns[0].targetIndex\n          })\n        }\n      }\n    })\n\n    return this.toArray().then(rows => {\n      //\n      // Extract the mix of all related keys in all rows\n      //\n      let queries = usableForeignTables\n        .map(foreignTable => {\n          // For each foreign table, query all items that any row refers to\n          let tableName = foreignTable.tableName\n          let allRelatedKeys = rows\n            .map(row => row[foreignTable.targetIndex])\n            .filter(isIndexableType)\n\n          // Build the Collection to retrieve all related items\n          return databaseTables[tableName]\n              .where(foreignTable.index)\n              .anyOf(allRelatedKeys)\n        })\n\n      // Execute queries in parallell\n      let queryPromises = queries.map(query => query.toArray())\n\n      //\n      // Await all results and then try mapping each response\n      // with its corresponding row and attach related items onto each row\n      //\n      return Promise.all(queryPromises).then(queryResults => {\n        usableForeignTables.forEach((foreignTable, idx) => {\n          let tableName = foreignTable.tableName\n          let result = queryResults[idx]\n          let targetIndex = foreignTable.targetIndex\n          let foreignIndex = foreignTable.index\n          let column = foreignTable.column\n\n          // Create a lookup by targetIndex (normally 'id')\n          // and set the column onto the target\n          let lookup = {}\n          result.forEach(record => {\n            let foreignKey = record[foreignIndex]\n            if (foreignTable.oneToOne) {\n              lookup[foreignKey] = record\n            } else {\n              (lookup[foreignKey] = lookup[foreignKey] || [])\n                .push(record)\n            }\n          })\n\n          // Populate column on each row\n          rows.forEach(row => {\n            let foreignKey = row[targetIndex]\n            let record = lookup[foreignKey]\n            if (foreignKey !== null && foreignKey !== undefined && !record) {\n              throw new Error(\n                `Could not lookup foreign key where ` +\n                `${tableName}.${foreignIndex} == ${baseTable}.${column}. ` +\n                `The content of the failing key was: ${JSON.stringify(foreignKey)}.`)\n            }\n\n            // Set it as a non-enumerable property so that the object can be safely put back\n            // to indexeddb without storing relations redundantly (IndexedDB will only store \"own non-\n            // enumerable properties\")\n            Object.defineProperty(row, column, {\n              value: record,\n              enumerable: false,\n              configurable: true,\n              writable: true\n            })\n          })\n        })\n      }).then(() => rows)\n    })\n  }\n\n  db.Version.prototype._parseStoresSpec = Dexie.override(\n    db.Version.prototype._parseStoresSpec,\n    parseStoresSpec => function (storesSpec, outDbSchema) {\n      const parser = new SchemaParser(storesSpec)\n\n      let foreignKeys = parser.getForeignKeys()\n      // call the original method\n      let rv = parseStoresSpec.call(this, parser.getCleanedSchema(), outDbSchema)\n\n      // set foreign keys into database table objects\n      // to use later in 'with' method\n      Object.keys(outDbSchema).forEach(table => {\n        if (foreignKeys.hasOwnProperty(table)) {\n          outDbSchema[table].foreignKeys = foreignKeys[table]\n          foreignKeys[table].forEach(fk => {\n            outDbSchema[table].idxByName[fk.index].foreignKey = fk\n          })\n        }\n      })\n\n      return rv\n    })\n}\n\n// https://github.com/dfahlander/Dexie.js/issues/625:\nRelationships.default = Relationships\n\nexport default Relationships\n"],"names":["isIndexableType","value","Date","Array","isArray","every","SchemaParser","schema","this","getForeignKeys","foreignKeys","Object","keys","forEach","table","indexes","split","filter","idx","indexOf","map","x","trim","column","target","index","targetTable","targetIndex","getCleanedSchema","join","const","Relationships","db","Promise","Dexie","Table","prototype","with","relationships","toCollection","Collection","baseTable","_ctx","name","databaseTables","_allTables","usableForeignTables","let","tableOrIndex","matchingIndex","idxByName","hasOwnProperty","push","foreignKey","tableName","oneToOne","Error","columns","length","toArray","then","rows","queries","foreignTable","allRelatedKeys","row","where","anyOf","queryPromises","query","all","queryResults","result","foreignIndex","lookup","record","undefined","JSON","stringify","defineProperty","enumerable","configurable","writable","Version","_parseStoresSpec","override","parseStoresSpec","storesSpec","outDbSchema","parser","rv","call","fk","default"],"mappings":"+NACO,SAASA,GAAiBC,GAC/B,MAAgB,OAATA,IACc,gBAAVA,IACU,gBAAVA,IACPA,YAAiBC,OAChBC,MAAMC,QAAQH,IAAUA,EAAMI,MAAML,+BCN3C,IAAMM,GAAa,SAOJC,GACbC,KAAOD,OAASA,EAQlBD,aAAEG,qCACMC,IAmBN,OAjBAC,QAASC,KAAKJ,KAAKD,QAAQM,QAAQ,SAAAC,GACjC,GAAMC,GAAUP,EAAKD,OAAOO,GAAOE,MAAM,IAEzCN,GAAcI,GAASC,EAClBE,OAAO,SAAAC,UAA8B,IAAvBA,EAAIC,QAAQ,QAC1BC,IAAI,SAAAF,GAEL,MAAyBA,EAAIF,MAAM,MAAMI,IAAI,SAAAC,SAAKA,GAAEC,SAA7CC,OAAQC,MAEf,QACEC,MAASF,EACTG,YAAeF,EAAOR,MAAM,KAAK,GACjCW,YAAeH,EAAOR,MAAM,KAAK,QAKhCN,GAQXJ,YAAEsB,uCACMrB,IASN,OAPAI,QAASC,KAAKJ,KAAKD,QAAQM,QAAQ,SAAAC,GACjC,GAAMC,GAAUP,EAAKD,OAAOO,GAAOE,MAAM,IAGzCT,GAASO,GAASC,EAAQK,IAAI,SAAAF,SAAOA,GAAIF,MAAM,MAAM,GAAGM,SAAQO,KAAK,OAG9DtB,EClDXuB,IAAMC,GAAgB,SAACC,GAErBF,GAAMG,GAAUC,EAAMD,OAStBD,GAAGG,MAAMC,UAAUC,KAAO,SAAUC,GAClC,MAAO9B,MAAK+B,eAAeF,KAAKC,IAUlCN,EAAGQ,WAAWJ,UAAUC,KAAO,SAAUC,cACjCG,EAAYjC,KAAKkC,KAAK5B,MAAM6B,KAC5BC,EAAiBZ,EAAGa,WAGtBC,IAyCJ,OAtCAnC,QAAOC,KAAK0B,GAAezB,QAAQ,SAACU,GAClCwB,GAAIC,GAAeV,EAAcf,GAC7B0B,EAAgBzC,EAAKkC,KAAK5B,MAAMP,OAAO2C,UAAUF,EAErD,IAAIC,GAAiBA,EAAcE,eAAe,cAAe,CAC/DJ,GAAItB,GAAQwB,CACZH,GAAoBM,MAClB7B,OAAQA,EACRE,MAAOA,EAAM4B,WAAW1B,YACxB2B,UAAW7B,EAAM4B,WAAW3B,YAC5BC,YAAaF,EAAM4B,WAAW5B,MAC9B8B,UAAU,QAEP,CACLR,GAAIjC,GAAQkC,CAEZ,KAAKJ,EAAeO,eAAerC,GACjC,KAAM,IAAI0C,OAAM,sBAAwB1C,EAAQ,kBAGlD,KAAK8B,EAAe9B,GAAOP,OAAO4C,eAAe,eAC/C,KAAM,IAAIK,OAAM,sBAAwB1C,EAAQ,kCAIlDiC,IAAIU,GAAUb,EAAe9B,GAAOP,OAAOG,YAAYO,OAAO,SAAAM,SAAUA,GAAOG,cAAgBe,GAE3FgB,GAAQC,OAAS,GACnBZ,EAAoBM,MAClB7B,OAAQA,EACRE,MAAOgC,EAAQ,GAAGhC,MAClB6B,UAAWxC,EACXa,YAAa8B,EAAQ,GAAG9B,iBAMzBnB,KAAKmD,UAAUC,KAAK,SAAAC,GAIzBd,GAAIe,GAAUhB,EACX1B,IAAI,SAAA2C,GAEHhB,GAAIO,GAAYS,EAAaT,UACzBU,EAAiBH,EAClBzC,IAAI,SAAA6C,SAAOA,GAAIF,EAAapC,eAC5BV,OAAOjB,EAGV,OAAO4C,GAAeU,GACjBY,MAAMH,EAAatC,OACnB0C,MAAMH,KAIXI,EAAgBN,EAAQ1C,IAAI,SAAAiD,SAASA,GAAMV,WAM/C,OAAO1B,GAAQqC,IAAIF,GAAeR,KAAK,SAAAW,GACrCzB,EAAoBjC,QAAQ,SAACkD,EAAc7C,GACzC6B,GAAIO,GAAYS,EAAaT,UACzBkB,EAASD,EAAarD,GACtBS,EAAcoC,EAAapC,YAC3B8C,EAAeV,EAAatC,MAC5BF,EAASwC,EAAaxC,OAItBmD,IACJF,GAAO3D,QAAQ,SAAA8D,GACb5B,GAAIM,GAAasB,EAAOF,EACpBV,GAAaR,SACfmB,EAAOrB,GAAcsB,GAEpBD,EAAOrB,GAAcqB,EAAOrB,QAC1BD,KAAKuB,KAKZd,EAAKhD,QAAQ,SAAAoD,GACXlB,GAAIM,GAAaY,EAAItC,GACjBgD,EAASD,EAAOrB,EACpB,IAAmB,OAAfA,OAAsCuB,KAAfvB,IAA6BsB,EACtD,KAAM,IAAInB,OACR,sCACAF,MAAgBmB,SAAmBhC,MAAalB,2CACTsD,KAAKC,UAAUzB,OAM1D1C,QAAOoE,eAAed,EAAK1C,GACzBtB,MAAO0E,EACPK,YAAY,EACZC,cAAc,EACdC,UAAU,UAIftB,KAAK,iBAAMC,QAIlB7B,EAAGmD,QAAQ/C,UAAUgD,iBAAmBlD,EAAMmD,SAC5CrD,EAAGmD,QAAQ/C,UAAUgD,iBACrB,SAAAE,SAAmB,UAAUC,EAAYC,GACvC1D,GAAM2D,GAAS,GAAInF,GAAaiF,GAE5B7E,EAAc+E,EAAOhF,iBAErBiF,EAAKJ,EAAgBK,KAAKnF,KAAMiF,EAAO7D,mBAAoB4D,EAa/D,OATA7E,QAAOC,KAAK4E,GAAa3E,QAAQ,SAAAC,GAC3BJ,EAAYyC,eAAerC,KAC7B0E,EAAY1E,GAAOJ,YAAcA,EAAYI,GAC7CJ,EAAYI,GAAOD,QAAQ,SAAA+E,GACzBJ,EAAY1E,GAAOoC,UAAU0C,EAAGnE,OAAO4B,WAAauC,OAKnDF,YAKb3D,GAAc8D,QAAU9D"}